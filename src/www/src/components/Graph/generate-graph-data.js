// Generated by CoffeeScript 1.9.0

/*
Generate preformatted data of commits graph.
 */
let Node, generateGraphData, remove;

generateGraphData = function (commits) {

    /*
  Generate graph data.
  
  :param commits: a list of commit, which should have
    `sha`, `parents` properties.
  :returns: data nodes, a json list of
    [
      sha,
      [offset, branch], //dot
      [
      [from, to, branch],  // route 1
      [from, to, branch],  // route 2
      [from, to, branch],
      ]  // routes
    ],  // node
   */
    let b, branch, branchIndex, branches, commit, getBranch, i, node, nodes, numParents, offset, otherBranch, reserve, routes, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1;
    nodes = [];
    branchIndex = [0];
    reserve = [];
    branches = {};
    getBranch = function (sha) {
        if (branches[sha] == null) {
            branches[sha] = branchIndex[0];
            reserve.push(branchIndex[0]);
            branchIndex[0]++;
        }
        return branches[sha];
    };
    for (_i = 0, _len = commits.length; _i < _len; _i++) {
        commit = commits[_i];
        branch = getBranch(commit.sha);
        numParents = commit.parents.length;
        offset = reserve.indexOf(branch);
        routes = [];
        if (numParents === 1) {
            if (branches[commit.parents[0]] != null) {
                _ref = reserve.slice(offset + 1);
                for (i = _j = 0, _len1 = _ref.length; _j < _len1; i = ++_j) {
                    b = _ref[i];
                    routes.push([i + offset + 1, i + offset + 1 - 1, b]);
                }
                _ref1 = reserve.slice(0, offset);
                for (i = _k = 0, _len2 = _ref1.length; _k < _len2; i = ++_k) {
                    b = _ref1[i];
                    routes.push([i, i, b]);
                }
                remove(reserve, branch);
                routes.push([offset, reserve.indexOf(branches[commit.parents[0]]), branch]);
            } else {
                for (i = _l = 0, _len3 = reserve.length; _l < _len3; i = ++_l) {
                    b = reserve[i];
                    routes.push([i, i, b]);
                }
                branches[commit.parents[0]] = branch;
            }
        } else if (numParents === 2) {
            branches[commit.parents[0]] = branch;
            for (i = _m = 0, _len4 = reserve.length; _m < _len4; i = ++_m) {
                b = reserve[i];
                routes.push([i, i, b]);
            }
            otherBranch = getBranch(commit.parents[1]);
            routes.push([offset, reserve.indexOf(otherBranch), otherBranch]);
        }
        node = Node(commit.sha, offset, branch, routes);
        nodes.push(node);
    }
    return nodes;
};

remove = function (list, item) {
    list.splice(list.indexOf(item), 1);
    return list;
};

Node = function (sha, offset, branch, routes) {
    return [sha, [offset, branch], routes];
};

module.exports = generateGraphData;
